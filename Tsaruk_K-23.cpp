Царук Р. М. К-23
Білет № 1

1. 
Складність алгоритму - оцінка часу роботи алгоритму в залежності від кількості вхідних даних; 
характеристика, що відповідає на запитання, як зміниться час роботи (або кількість зайнятої програмою памяті - просторова складність), якщо збільшити кількість вхідних даних.
Складність алгоритму виражається з використанням нотації «O», яка у формулі залежності часу від кількості данних n враховує тільки доданок найвищого порядку, 
а також не враховує константні множники (коефіцієнти).

Найпоширеніші складності алгоритмів (від найшвидших до найповільніших):

O(1) — константний час. Знаходження елементу із заданим індексом в масиві (лінійний чи бінарний пошук), вставка і видалення у списках, основні команди хеш таблиць. 
O(log n) — логарифмічний. Знаходження елементу у відсортованому масиві. Операції з бінарними деревами та кучами.
O(n) — лінійний. Лінійний пошук (використовується у списках).
O(n*log n) — лінійно-логарифмічний. Середня складність багатьох алгоритмів сортування (швидке, злиттям).
O(n^2) — квадратичний. Бульбашкове сортування в найгіршому випадку.
O(2^n) — експотенціальний. Розграхунок чисел Фіббоначі.
O(n!) — факторіальний. Знаходження факториалу числа в рекурсії.


Зазвичай визначають складність алгоритму в найгіршому випадку або середню складність алгритму.
+ Амортизована складність - середня складність однієї виконання однієї операції для алгоримтів, які допускають додаткові незначні часові затрати, к-сть яких росте не швидше к-сті операцій.


2.
ООП — одна з парадигм програмування, яка розглядає програму як множину об'єктів, що взаємодіють між собою. ООП використовують через його переваги:

Переваги ООП:

    Можливість легкої модифікації (при грамотному аналізі і проектуванні)
    Можливість повернення до попередьної версії при наявності версій
	Значно легша розширюваність і масштабування
    «Більш природна» декомпозиція програмного забезпечення, яка істотно полегшує його розробку
    Збільшується показник повторного використання коду
	
Недоліки ООП:

    Збільшується час на аналіз і проектування систем
    Неефективно з точки зору пам'яті, більше коду, довше виконання програми
    Складність розподілу робіт на початковому етапі
	Необхіде володіння концепціями ООП

Основні концепції:

Успадкування (наслідування)
    Клас може мати «підкласи» - класи нащадки. Можуть навіть утворюватись цілі дерева успадкування. 
	Підкласи успадковують атрибути та поведінку своїх батьківських класів, і можуть вводити свої власні. 
	Успадкування може бути одиничне (один безпосередній батьківський клас) та множинне (кілька батьківських класів).

Класичний приклад:

class Vehicle {
  public:
    string brand = "Ford";
    void honk() {
      cout << "Tuut, tuut! \n" ;
    }
};

class Car: public Vehicle {
  public:
    string model = "Mustang";
};

int main() {
  Car myCar;
  myCar.honk(); // Tuut, tuut!
  cout << myCar.brand + " " + myCar.model; // Ford Mustang
  return 0;
} 
	
В цьому прикладі обєкт класу Car є і обєктом більш широкого класу Vehicle. 
Використання успадкування означає, що нам не потрібно перевизначати інформацію з батьківських класів в дочірніх. Ми автоматично отримуємо методи і змінні-члени суперкласу через успадкування, 
а потім просто додаємо специфічні методи чи змінні для класа-нащадка. Таким чином дочірні класи уточнюють батьківські, доповнюють їх і забезпечують більш специфічний функціонал.
Інколи може бути корисне множинне успадкування - можливість класу бути нащадком зразу для декількох батьківських класів.

Інкапсуляція (приховування інформації)
    Приховування деталей про роботу класів від обєктів (екземплярів), що їх використовують чи надсилають їм повідомлення. 
	Так, наприклад, клас Студент має метод писати_екзамен(). Цей метод може бути реалізований через методи гуглити(), двзінок_другу() та інші, 
	але той, хто взаємодіє з обєктом Студент, може не знати як реалізований цей метод. Інкапсуляція досягається шляхом вказування, які класи можуть звертатися до членів обєкта. 
	Інкапсуляція потрібна для того, аби запобігти використанню користувачами інтерфейсу тих частин реалізації, які, швидше за все, будуть змінюватись. 
	Часто, члени класу позначаються як публічні (англ. public), захищені (англ. protected) та приватні (англ. private), визначаючи, 
	чи доступні вони всім класам, підкласам, або лише до класу в якому їх визначено.
	
Абстрагування
    Спрощення складної дійсності шляхом моделювання класів, що відповідають проблемі, та використання найприйнятнішого рівня деталізації окремих аспектів проблеми.
	Наприклад, Студент Караулкін більшу частину часу може розглядатись як Студент, але може бути розглянутий і як Тварина (можливо, батьківський клас для Студент).

Поліморфізм
    Поліморфізм означає примінимість операції для різних типів даних. Цей ж самий механізм дозволяє викликати різні, хоч і однойменні методи для кожного обєкта в залежності від його класу.
	
3.
#include <iostream>
#include <string>
#include <fstream>
using namespace std;

int search(char a) { 
    int n{};
    string str;
	fstream file("text.txt");
    while (getline (file, str)) {
        for (int i = 0; i < str.length(); i++) {
            if (str[i] == a) n++;
        }
    }
    file.close();
    return n;
}

int main() {
    char s[] = "abc"; // xyz - specify here all characters you need to count
    int c;
    int n = sizeof(s)/sizeof(s[0]); 
    for (int i = 0; i < n-1; i++) {
        c = search(s[i]);
        cout << s[i] << ":" << c << " ";
    }
    return 0;
}

4.
import unittest

def suma(arr):
    s = 0;
    for i in arr:
        s += i;
    return s

class TestSum(unittest.TestCase):
    def test_list_int(self):
        data = [1, 2, 3]
        result = suma(data)
        self.assertEqual(result, 6)
        
    def test_tuple_int(self):
        data = (1, 2)
        result = suma(data)
        self.assertEqual(result, 3)
        
if __name__ == '__main__':
    unittest.main()


дякую за увагу 
